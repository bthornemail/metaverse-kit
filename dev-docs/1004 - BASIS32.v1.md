BASIS32.v1

A Deterministic Feature Basis for Trace-Based Reality

Integrating PF16 Identity, Event Traces, and Native Feature Projection

Version: 1.0
Status: Draft for Implementation
Context: Community Metaverse / Trace-Based Reality Engine

Abstract

This paper defines BASIS32.v1, a deterministic 32-feature basis layer that projects event traces and PF16 identities into a compact, searchable, and reproducible feature space—without machine learning.

Unlike statistical models, BASIS32 is:

deterministic

replayable

versioned

projection-only (never authoritative)

compatible with append-only trace systems

BASIS32 enables:

search and discovery

routing and ranking

clustering and similarity

UI/UX adaptation

while preserving the core rule:

Law (PF16) governs what is allowed.
Basis (BASIS32) governs how it is perceived.

1. Position in the Architecture

The system has three semantic layers:

Event Trace → PF16 Identity → BASIS32 Features → Projections truth law perception views 

Events: what happened

PF16: who, where, under what authority and boundary

BASIS32: how this reality behaves and feels

Projections: 2D/3D/AR/VR/UI/search

BASIS32 is:

always derived

never authoritative

always recomputable

versioned as a basis contract

2. Why Not Machine Learning First

Machine learning:

drifts over time

is hard to replay exactly

is opaque

breaks determinism

Trace-based systems require:

replayability

determinism

auditable transformation

versioned semantics

So we start with a fixed basis, not a learned one.

ML can be layered later as:

Events → PF16 → BASIS32 → ML Projection 

Never:

ML → Law 

3. BASIS32 as a Coordinate System

BASIS32 is a fixed 32-dimensional coordinate system.

Each feature:

has a name

has an input domain

has a deterministic computation rule

has a bounded output range

can be quantized

This is not “meaning.”
It is measurement.

4. Feature Groups

A) Structural Features (from event/state graph)

node_count_log

link_count_log

component_count

churn_rate

edit_entropy

merge_frequency

tile_hop_spread

B) Scope & Authority (from PF16)

authority_source_ratio

boundary_strictness

policy_privacy_level

federation_size_log

witness_density

C) Intent (from PF16.I7_intent)

intent_emergency

intent_logistics

intent_chat

intent_mapping

intent_commerce

intent_art

intent_simulation

intent_sensor

D) Environment (from discovery and proximity)

geo_present

geo_accuracy_bucket

ble_rssi_bucket

wifi_rssi_bucket

lora_snr_bucket

peer_density

broker_hops

E) Motion & Stability

avg_velocity_bucket

collision_rate_bucket

stability_score

anomaly_score_rule

recency_decay

5. Feature Computation

Each feature is computed from:

event windows

tile state

PF16 identity

discovery hints

Example:

node_count_log = log2( number_of_nodes_in_tile + 1 ) bucketed to 0..3 authority_source_ratio = (#source events) / (#total events) bucketed to 0..3 intent_emergency = PF16.I7_intent contains "emergency" ? 1 : 0 

No randomness.
No training.
Same input → same output.

6. Quantization and Packing

6.1 Bucketing

Each feature is mapped to a small integer:

0..3 (2 bits)

or 0..15 (4 bits)

6.2 Packing

Two main formats:

Compact: 32 × 2 bits = 64-bit

Extended: 32 × 4 bits = 128-bit

Packed form:

packed64 = uint64 bitfield packed128 = two uint64s 

This allows:

fast comparison

fast routing

small storage

embedded-device support

7. Feature Event Format

Features are emitted as derived events:

{ "operation": "derived_feature32", "authority": "derived", "basis": "BASIS32.v1", "for": { "tile": "z0/x12/y7", "rid": "sha256:..." }, "window": { "since_event": "evt-100", "until_event": "evt-200" }, "features": [2,1,0,3,...], "packed64": "0x8f12c4...", "timestamp": 1730003000 } 

These:

never affect truth

can be deleted and recomputed

can differ between basis versions

8. Native Dependence on PF16

PF16 provides stable coordinates:

PF16 SlotUsed ForI1 authoritysource ratioI2 scopeprivacy, opennessI3 boundarystrictnessI7 intentintent flagsI13 federationfederation sizeI9 witnesswitness density 

Thus BASIS32 is rooted in law but does not change it.

9. Basis vs Identity

LayerRoleMutable?PF16Law & identityVery slow, conservativeBASIS32PerceptionFast, replaceableProjectionsUIEphemeral 

Rule:

PF16 decides what is allowed.
BASIS32 decides what is similar.
UI decides what is shown.

10. Search and Routing

Search can operate on:

exact packed64 match

Hamming distance between packed bits

bucket ranges

feature masks

Example:

find tiles where: intent_emergency = 1 geo_present = 1 recency_decay > 1 

Which is a bitmask + compare operation.

11. Federation and Divergence

Different peers may:

use BASIS32.v1

later BASIS32.v2

or custom bases

That’s allowed, because:

features are derived

never authoritative

versioned

Peers can exchange basis version metadata.

12. Relationship to Machine Learning

ML can consume BASIS32:

Events → PF16 → BASIS32 → ML → UI Ranking 

But ML output:

is always derived

never used for acceptance/rejection

never alters PF16 or events

ML is a projector, not a lawgiver.

13. Failure Modes Avoided

By using BASIS32 instead of ML-first:

no training drift

no hidden semantics

no irreproducible history

no authority confusion

Everything remains:

replayable

auditable

deterministic

14. Implementation Summary

To implement BASIS32:

Define BASIS32.v1 spec

Implement deterministic extractor

Quantize to buckets

Pack to 64-bit/128-bit

Emit derived feature events

Index for search

Use in UI and routing

Never:

use features to accept/reject events

let features modify PF16

treat features as truth

15. Final Principle

Identity is law.
Features are perception.
Perception must never become law.

BASIS32 is how reality becomes searchable—
without ceasing to be replayable.

